---
title: "Network Diffusion: Infectious Diseases"
format: gfm
---


```{r, setup, include=FALSE}
knitr::opts_chunk$set(paged.print = FALSE)
```

In this tutorial, we will cover dynamic epidemiological models of diffusion. We will focus on the substantive case of infection spread (like HIV or HCV) through a risk network (like drug use or a sex network). We are particularly interested in how the features of the network shape the potential for widespread contagion. For example, how much does the epidemic potential decrease if the number of current partners (e.g., number of sex partners during a given period) decreases dramatically, so that network density decreases? We are also interested in how risk behavior affects contagion potential.

We will utilize a dynamic network simulation in this tutorial. Simulation models are useful as they can be conditioned on empirical data, while also making it possible to explore complex, non-linear dynamics; i.e., how individual behavior and wider network features combine to shape infection potential. The model is dynamic as the network is allowed to evolve as the simulation progresses. Thus, both the network ties and the item of interest (the infection spreading over the network) are allowed to update over time. The focus is still on contagion, but actors are able to form and break ties as the simulation progresses; making it possible to explore how the process of tie formation, dissolution and maintenance affect the risk profile of a population, in terms of infection spread.

With EpiModel, the basic idea is to specify two kinds of processes, one related to the formation and breaking of network ties, and one related to the spread of an infection through the network, dictating how an infection is spread from node i to node j. 

# Data Prep

```{r}
#| message: false
library(EpiModel)
```

Here, we will use a faux ego network data set. We can assume that this data is drawn from an at-risk population of drug users. The data includes the following information about the respondent, or ego: 

- the number of alters named for each ego (with no cap)
- where ego lives (city or suburbs)
- information on up to 3 named drug partners
- whether each named alter lives in the city or suburbs. 

We can assume that ego reports on the location for each alter. 

```{r}
url1 <- "https://github.com/JeffreyAlanSmith/Integrated_Network_Science/raw/master/data/ego_network_example_data.txt"

ego_dat <- read.table(file = url1, header = T, stringsAsFactors = FALSE)
head(ego_dat)
```

Degree is number of drug partners.

# Specifying the Network Model

## Size

Must specify network size. Can use population size, if known. Here will use sample size.

```{r}
num_nodes <- nrow(ego_dat)
num_nodes
```

Create an empty, undirected network.

```{r}
epi_network <- network.initialize(n = num_nodes, directed = F)
```

Add node attributes.

```{r}
epi_network <- set.vertex.attribute(epi_network,
  attrname = "location",
  value = ego_dat$location
)
epi_network
```

## Model formation of ties

A simple model, with terms for edges and nodefactor and nodematch for location.

```{r}
formation_formula <- formula(~ edges + nodefactor("location") +
  nodematch("location"))
```

Set target statistics for each term based on the ego network data.

> Set baseline number of edges

```{r}
mean_degree <- mean(ego_dat$degree)
mean_degree
```

```{r}
edges <- mean_degree * num_nodes / 2 # divide by 2 because undirected
edges
```

> Nodefactor

The nodefactor term is defined by the total number of ties emanating from one group. This is defined as: the mean degree of the group * the number of people in that group. 

```{r}
mean_degree_location <- tapply(
  X = ego_dat$degree, INDEX = ego_dat$location,
  FUN = mean
)
mean_degree_location
```

```{r}
tab_location <- table(ego_dat$location)
tab_location
```

```{r}
edges_by_group <- mean_degree_location * tab_location
edges_by_group
```

Use "city" as reference category.

```{r}
edges_suburbs <- edges_by_group[2]
```

> Nodematch target

We need to calculate the number of edges we expect to match on location (so ij are both in the city or both in the suburbs). 

```{r}
location_cols <- c("location1", "location2", "location3")
same_location <- ego_dat[, "location"] == ego_dat[, location_cols]
head(same_location)
```

```{r}
prop_match <- prop.table(table(same_location))
prop_match
```

So, about .808 of edges should match on location. Note that we still need to calculate the number of edges we expect to match on location (so far we just have the proportion). 

```{r}
num_match <- round(prop_match[[2]] * edges)
num_match
```

> Create target statistic input vector

```{r}
target_statistics_baseline <- c(
  edges = edges,
  nodefactor.location = edges_suburbs,
  nodematch.location = num_match
)
target_statistics_baseline
```

## Model breaking of ties

 This is set via a dissolution_coefs() function. The arguments are:

    - dissolution = a formula that determines how edges are dropped. This can take a number of forms. The simplest version is that all edges are dropped at the same rate; a more complicated model could allow edges of certain characteristics to end at different rates (so we may think that if two people share the same characteristic, then the edge may last longer).
    - duration = the average duration of an edge in the simulation; this is recorded in arbitrary time units (but we can think of this as months for concreteness)
    - d.rate = the death rate of the population (so that nodes can leave the network across time, at least potentially).

Here, we create a fairly simple dissolution model. In this case, all edges dissolve at the same rate (set using `offset(edges)`), with average duration of 25 time units (not based on actual data, although it could be). The exit, or death rate, is set at .001.

```{r}
dissolution_coefs <- dissolution_coefs(
  dissolution = ~ offset(edges),
  duration = 25, d.rate = .001
)
dissolution_coefs
```

# Estimating the Network Model

We now estimate the statistical network model that will be used in our epidemiological simulation. The function is netest(), which is a wrapper for the ergm() and tergm() functions explored in Chapter 13. The main arguments are:

    - nw = network object used as basis for simulation
    - formation = formula specifying formation of edges
    - target.stats = input target statistics corresponding to formation formula
    - coefs.diss = coefficients for dissolution of edges

```{r}
set.seed(1002)
net_mod <- netest(
  nw = epi_network, formation = formation_formula,
  target.stats = target_statistics_baseline,
  coef.diss = dissolution_coefs
)
```


```{r}
#| message: false
set.seed(1002)
net_mod <- netest(
  nw = epi_network, formation = formation_formula,
  target.stats = target_statistics_baseline,
  coef.diss = dissolution_coefs
)
summary(net_mod)
```

## Check if model is producing networks that match target statistics. Can do static for one time period or dynamic, taking into account formation and dissolution.

The main arguments to netdx() are:

    - x = model estimated from netest
    - nsims = number of simulated networks
    - dynamic = should look at dynamic statistics (T/F)?
    - nsteps = number of time periods in dynamic simulation
    - nwstats.formula = formula of statistics to test against, default is the target statistics specified in the formation formula.

Check static fit.

```{r net-diff-model-plot-1}
mod_fit1 <- netdx(x = net_mod, dynamic = F, nsims = 1000)
plot(mod_fit1, legend = T)
```

Static fit looks good. Now check dynamic for 300 time periods.

```{r}
mod_fit2 <- netdx(x = net_mod, dynamic = T, nsims = 5, nsteps = 300)
mod_fit2
```

```{r net-diff-model-plot-2}
plot(mod_fit2, legend = T)
```

This seems reasonable, though different from the source text.

Check duration and dissolution of ties.

```{r net-diff-model-plot-3}
par(mfrow = c(1, 2))
plot(mod_fit2, type = "duration")
plot(mod_fit2, type = "dissolution")
```

# Specifying the Epidemic Model

The second main step is to specify the epidemic part of the simulation, determining the manner in which the infection spreads through social connections. EpiModel allows for a flexible range of models to be specified, although it is also possible to write additional code to extend the functionality of the package. Here, we will consider a simple contagion model, where actors, once infected, can pass it on to those they interact with (e.g., share needles with) in a given time period. In the language of epidemiological studies, we will consider a SIS model (susceptible-infected-susceptible) where actors are either infected or susceptible to be infected. We will assume that actors can be reinfected, once recovered. We could alternatively assume that actors cannot be reinfected, thus running an SIR model (susceptible-infected-recovered). To run an epidemiological simulation, in conjunction with our network model specified above, we need to create a number of inputs, shaping the features of the simulation.

> Set initial state

As a first step, we need to create a vector that captures the initial state that each node is in at the start of the simulation. Each node must be set to a "s" "i" or "r" for susceptible, infected or recovered. Here, let's randomly select 3% of the population to be infected. We will use a sample() function, randomly sampling an s, i, or r state for each node, with probability .97, .03 and 0 (so no one is recovered). We set size to num_nodes so that each node in the simulation will have an initial state.

```{r}
initial_status <- sample(c("s", "i", "r"),
  size = num_nodes,
  replace = T, prob = c(.97, .03, 0)
)
table(initial_status)
```

```{r}
initial_status_inputs <- init.net(status.vector = initial_status)
```

> Set probabilities of infection and recovery

using a param.net() function. The arguments are:

    - inf.prob = the probability of infection in a given interaction (or act)
    - act.rate = number of interactions (or acts) in a time period between i and j, assuming that i and j are connected in that period.
    - rec.rate = the rate of recovery in a time period

Here we will we set the probability of infection to .025, so that in a given act between i and j (like sharing needles) the probability of infection is .025. We set the number of acts per period to 1. This means that a pair, ij, that have a relationship have 1 risk event per period. In each risk event, node i, if infected, can pass the infection to j. Finally, we set the recovery rate to .01, so that a node has a .01 probability of recovering in a given time period. 

```{r}
input_to_episim <- param.net(
  inf.prob = 0.025, act.rate = 1,
  rec.rate = 0.01
)
input_to_episim
```

> Create control object

Here we use the control.net() function. The main arguments are:

    - type = SI, SIR, SIS
    - nsteps = number of time periods for simulation
    - nsims = number of simulations to perform
    - ncores = number of processors to use in simulation (if multiple cores are to be used)

```{r}
control_episim <- control.net(
  type = "SIS", nsteps = 300,
  nsims = 4, ncores = 4
)
control_episim
```

# Running Simulations

## Baseline Model

We can now run our epidemiological simulation using the netsim() function. The main arguments are:

    - x = fitted network model, based on netest() function
    - param = model parameters, based on param.net() function
    - init = initial status inputs, based on init.net() function
    - control = control object, based on control.net() function

```{r}
episim_baseline <- netsim(
  x = net_mod, param = input_to_episim,
  init = initial_status_inputs,
  control = control_episim
)
summary_data_baseline <- as.data.frame(episim_baseline, out = "mean")
head(summary_data_baseline)
```

Check at different time periods.

```{r}
summary(episim_baseline, at = 1)
```

```{r}
summary(episim_baseline, at = 100)
```

```{r net-diff-model-plot-4}
plot(episim_baseline, y = c("i.num", "s.num"), legend = T)
```

Infection spreads quickly, over 80% infected after 100 periods.

## Varying network features

Here, we will keep the basic epidemiological simulation the same but tweak the network features to see how this changes the epidemic potential. In particular, we will ask how the spread of infection through the population is affected when the number of partners per person decreases substantially. We will assume that the number of edges in the network in a given time period is cut in half. Here individuals have, on average, degree of 1.854, rather than 3.707. 

To construct inputs for the simulation, we will take the target statistics used originally and simply multiple all of them by .5. This will directly cut the number of edges in half. It will also ensure that all of the other target statistics, like nodematch on location, are based on the new desired number of edges (here half the original).

```{r}
target_statistics_lowdegree <- round(target_statistics_baseline * .5)
target_statistics_lowdegree
```

```{r}
net_mod_lowdegree <- netest(
  nw = epi_network, formation = formation_formula,
  target.stats = target_statistics_lowdegree,
  coef.diss = dissolution_coefs
)
```

```{r}
mod_fit_lowdegree <- netdx(
  x = net_mod_lowdegree, dynamic = T,
  nsims = 5, nsteps = 300
)
```

```{r net-diff-model-plot-5}
plot(mod_fit_lowdegree, legend = T)
```

```{r}
episim_lowdegree <- netsim(
  x = net_mod_lowdegree, param = input_to_episim,
  init = initial_status_inputs,
  control = control_episim
)
summary_data_lowdegree <- as.data.frame(episim_lowdegree, out = "mean")
```

And let's compare period 10, 25, 50, 100, 150 and 300 between the two simulations, just including the number infected (i.num in the summary data frames).

```{r}
period <- c(10, 25, 50, 100, 150, 300)
i_num_baseline <- summary_data_baseline[, "i.num"]
i_num_lowdegree <- summary_data_lowdegree[, "i.num"]

compare_dat <- data.frame(
  period = period,
  i.num.baseline = i_num_baseline[period],
  i.num.lowdegree = i_num_lowdegree[period]
)
compare_dat
```

```{r net-diff-model-plot-6}
diff_infected <- i_num_baseline - i_num_lowdegree

plot(1:300, diff_infected,
  xlab = "period",
  ylab = "Difference in number infected",
  main = "Comparison of Baseline to Low Degree Simulation"
)
```

Plot the diffusion curves.

```{r net-diff-model-plot-7}
par(mfrow = c(1, 2))

plot(episim_baseline,
  y = c("i.num", "s.num"),
  legend = TRUE, main = "Baseline"
)

plot(episim_lowdegree,
  y = c("i.num", "s.num"),
  legend = TRUE, main = "Low Degree"
)
```

## Varying Epidemic Model

Lower the number of interactions per period.

```{r}
input_to_episim_lowinteraction <- param.net(
  inf.prob = 0.025,
  act.rate = .40, rec.rate = 0.01
)
```

```{r}
episim_lowinteraction <- netsim(
  x = net_mod,
  param = input_to_episim_lowinteraction,
  init = initial_status_inputs,
  control = control_episim
)
```

```{r net-diff-model-plot-8}
par(mfrow = c(1, 2))

plot(episim_baseline,
  y = c("i.num", "s.num"),
  legend = T, main = "Baseline"
)

plot(episim_lowinteraction,
  y = c("i.num", "s.num"),
  legend = T, main = "Low Interactions"
)
```


