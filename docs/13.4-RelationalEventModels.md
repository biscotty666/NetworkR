# Relational Event Models


Relational event models are based on micro-interaction data. The model
assumes that there is time-stamped (or at least ordered) information on
the interactions between a set of actors. This shifts the focus from
discrete relationships (friend, advice, etc.) to the specific
interactions between actors in a setting. The goal of the model is to
predict what the next event is likely to be, based on the interactional
tendencies, or rules, of behavior in the setting. Compare this to
STERGM, where the goal is to predict the adding/dropping of ties from
one period to the next, based on discretely defined networks.

Here we consider one classroom on two different days; both days are in
the second semester of the year. We pick two days as a means of
comparison. The first day was relatively uneventful and class was
orderly. The second day was different, as there was a much higher rate
of sanctioning behavior (i.e., disagreements between students and
teacher on what was going on in the classroom). By examining two days,
we see if the interactional signatures of order and disorder are
different.

# Data Preparation

``` r
library(relevent)
library(sna)
```

``` r
# url1 <- "https://github.com/JeffreyAlanSmith/Integrated_Network_Science/raw/master/data/class_interactions_date1.txt"

interactions_date1 <- read.table("../data/class_interactions_date1.txt", header = T)
head(interactions_date1[, c("send_col", "receive_col", "time_estimate_col")])
```

      send_col receive_col time_estimate_col
    1       11           2             0.143
    2        2          11             0.286
    3        2           5             0.429
    4        5           2             0.571
    5        9           8             0.714
    6        8           9             0.857

``` r
str(interactions_date1)
```

    'data.frame':   279 obs. of  25 variables:
     $ cls_id            : int  182 182 182 182 182 182 182 182 182 182 ...
     $ cls_date          : chr  "3/27/97" "3/27/97" "3/27/97" "3/27/97" ...
     $ send_col          : int  11 2 2 5 9 8 7 1 3 11 ...
     $ receive_col       : int  2 11 5 2 8 9 1 7 11 3 ...
     $ time_estimate_col : num  0.143 0.286 0.429 0.571 0.714 ...
     $ type_col          : int  13 13 13 13 13 13 13 13 13 13 ...
     $ time_col          : int  6 6 6 6 6 6 6 6 6 6 ...
     $ private_col       : int  0 0 0 0 0 0 0 0 0 0 ...
     $ social_col        : int  1 1 1 1 1 1 1 1 1 1 ...
     $ public_task_col   : int  0 0 0 0 0 0 0 0 0 0 ...
     $ private_task_col  : int  0 0 0 0 0 0 0 0 0 0 ...
     $ public_social_col : int  1 1 1 1 1 1 1 1 1 1 ...
     $ private_social_col: int  0 0 0 0 0 0 0 0 0 0 ...
     $ question_col      : int  0 0 0 0 0 0 0 0 0 0 ...
     $ answer_col        : int  0 0 0 0 0 0 0 0 0 0 ...
     $ teach_talk_col    : int  0 0 0 0 0 0 0 0 0 0 ...
     $ to_all_col        : int  0 0 0 0 0 0 0 0 0 0 ...
     $ from_all_col      : int  0 0 0 0 0 0 0 0 0 0 ...
     $ hand_col          : int  0 0 0 0 0 0 0 0 0 0 ...
     $ sanction_col      : int  0 0 0 0 0 0 0 0 0 0 ...
     $ praise_col        : int  0 0 0 0 0 0 0 0 0 0 ...
     $ right_col         : int  0 0 0 0 0 0 0 0 0 0 ...
     $ wrong_col         : int  0 0 0 0 0 0 0 0 0 0 ...
     $ cheat_col         : int  0 0 0 0 0 0 0 0 0 0 ...
     $ joke_col          : int  0 0 0 0 0 0 0 0 0 0 ...

Data must be time-ordered, and each event’s time period must be unique.
Not appropriate for cases with a large number of simultaneous events.

For the sake of simplicity, we will remove all interactions directed
from the teacher to all students or from all students to the teacher.

``` r
not_to_all <- interactions_date1$to_all_col == 0
not_from_all <- interactions_date1$from_all_col == 0
interactions_date1 <- interactions_date1[not_to_all & not_from_all, ]
```

Create a matrix with time, sender and receiver.

``` r
edgelist_date1 <- as.matrix(
  interactions_date1[, c(
    "time_estimate_col",
    "send_col", "receive_col"
  )]
)
tail(edgelist_date1)
```

        time_estimate_col send_col receive_col
    274            42.528       11          17
    275            42.623       17          11
    276            42.717        3          11
    277            42.811       11           3
    278            42.906        7           8
    279            43.000        8           7

Add a row for stop time.

``` r
edgelist_date1 <- rbind(edgelist_date1, c(43.10, NA, NA))
```

Read in attribute data

``` r
# url2 <- "https://github.com/JeffreyAlanSmith/Integrated_Network_Science/raw/master/data/class_attributes.txt"

attributes <- read.table("../data/class_attributes.txt", header = T)
head(attributes)
```

      id gnd grd rce
    1  1   2  10   4
    2  2   2  10   3
    3  3   2  10   3
    4  4   2  10   3
    5  5   2  10   3
    6  6   1  10   4

There are four variables: - id - gnd (gender: 1 = male; 2 = female) -
grd (grade: 10 = 10; 11 = 11; 16 = teacher) - rce (race: 3 = Black; 4 =
White).

The relevent package requires that a researcher construct the node-level
predictors as distinct columns (as opposed to using a factor() function
within the formula). So, we will recode our variables to create the
desired dummy variables of interest. In this case, we will create a
predictor for whether the node is a teacher or not and for gender. We
also need to create a term for the intercept. We will utilize the
recode() function in the car package.

``` r
library(car)
```

Create a variable for the intercept, a 1 for all nodes.

``` r
attributes$intercept <- 1
```

Recode gender and teacher

``` r
attributes$male <- recode(attributes$gnd,
  as.factor = F,
  "1 = 1; 2 = 0"
)
attributes$teacher <- recode(attributes$grd,
  as.factor = F,
  "16 = 1; NA = NA; else = 0"
)
class_size <- nrow(attributes)
```

# Initial Models

Based on the logic of hazard models, risk of event occurring.

p-shifts are participation shifts, only based on the previous event. For
example, if A talks to B, B is likely to respond.

We are now in a position to run an initial relational event model. The
function is rem.dyad(). The main arguments are:

- edgelist = input edgelist in the form of time of event, sender,
  receiver
- n = size of network
- effects = vector with names of effects to be included in the model
- covar = list of covariates that must correspond to the terms specified
  in effects
- ordinal = T/F; T if data are ordinal (ordered but without specific
  time stamps); F if data include time specific information for each
  event

## Intercept only

Our first model will be very simple and just includes an intercept,
capturing the baseline rate for events to occur. We will set the effects
to CovSnd. CovSnd is a basic sender effect, in this case initiating
social interactions with others. We use the covar option to include
specific terms for CovSnd. In this case we include the intercept (so all
nodes are assumed to initiate interactions at the same rate). We set
ordinal to FALSE as the data has time stamped information.

``` r
set.seed(1000)
mod1 <- rem.dyad(
  edgelist = edgelist_date1, n = class_size,
  effects = c("CovSnd"),
  covar = list(CovSnd = attributes$intercept),
  ordinal = F, hessian = T
)
```

    Prepping edgelist.
    Checking/prepping covariates.
    Computing preliminary statistics
    Fitting model
    Obtaining goodness-of-fit statistics

``` r
summary(mod1)
```

    Relational Event Model (Temporal Likelihood)

              Estimate   Std.Err Z value  Pr(>|z|)    
    CovSnd.1 -4.057353  0.066213 -61.277 < 2.2e-16 ***
    ---
    Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
    Null deviance: 2306.34 on 228 degrees of freedom
    Residual deviance: 2306.34 on 228 degrees of freedom
        Chi-square: -3.830135e-05 on 0 degrees of freedom, asymptotic p-value 1 
    AIC: 2308.34 AICC: 2308.357 BIC: 2311.769 

- if we exponentiate this coefficient, we get the **hazard of any
  event** (i talking to j) occurring. Higher hazards mean the risk for
  an event occurring is higher.
- if we multiple the hazard rate by the number of possible node pairs
  who could interact in a given moment, n \* (n - 1), we should get the
  **expected number of interactions occurring per minute** in the
  classroom.
- if we take the inverse of that (1 / number of interactions per
  minute), we get the **expected amount of time between events**, or the
  wait time between events.

``` r
1 / (class_size * (class_size - 1) * exp(mod1$coef))
```

     CovSnd.1 
    0.1889576 

The expected time between any event occurring is .189 standardized
minutes (or .189 \* 60 = 11.34 seconds).

And let’s check this against the real data. We will take the total
number of minutes for that class and divide that by the total number of
interactions that occurred. We will define the total number of minutes
as 43.1, the end time set above.

``` r
total_classtime <- 43.1
num_interactions <- nrow(edgelist_date1) - 1
time_between_events <- total_classtime / num_interactions
time_between_events
```

    [1] 0.1890351

## Adding Sender and Receiver Effects

Let’s first add a term for gender (coded as male = 1 and female = 0). We
will add a sender effect, capturing whether males initiate fewer or
greater interactions than females, as well as a receiver effect,
capturing whether males receive fewer/greater interactions than females.

Create a matrix for each covariate.

``` r
CovSnd1 <- cbind(attributes[, c("intercept", "male")])
CovRec1 <- cbind(attributes[, c("male")])
mod2a <- rem.dyad(edgelist_date1,
  n = class_size,
  effects = c("CovSnd", "CovRec"),
  covar = list(CovSnd = CovSnd1, CovRec = CovRec1),
  ordinal = F, hessian = T
)
```

    Prepping edgelist.
    Checking/prepping covariates.
    Computing preliminary statistics
    Fitting model
    Obtaining goodness-of-fit statistics

``` r
names(mod2a$coef) <- c("Intercept", "Sender_male", "Receiver_male")
summary(mod2a)
```

    Relational Event Model (Temporal Likelihood)

                   Estimate   Std.Err  Z value  Pr(>|z|)    
    Intercept     -3.760406  0.084699 -44.3973 < 2.2e-16 ***
    Sender_male   -0.601249  0.160226  -3.7525 0.0001751 ***
    Receiver_male -0.460132  0.154017  -2.9875 0.0028123 ** 
    ---
    Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
    Null deviance: 2306.34 on 228 degrees of freedom
    Residual deviance: 2282.406 on 226 degrees of freedom
        Chi-square: 23.93399 on 2 degrees of freedom, asymptotic p-value 6.350391e-06 
    AIC: 2288.406 AICC: 2288.513 BIC: 2298.694 

Relative hazard for males to initiate the next interaction:

``` r
exp(-.601249)
```

    [1] 0.5481266

This means that an event with males initiating has a hazard that is
0.548 times lower than an event with females initiating.

Expected time between male-male events:

``` r
table(attributes$male)
```


     0  1 
    12  6 

There are 12 females and 6 males. There are 6 \* 5 ways a boy can be
sender and receiver.

``` r
dyads_at_risk <- 6 * 5
```

Multiply the coefficients by the input values

``` r
inputs <- c(intercept = 1, Sender_male = 1, Receiver_male = 1)
hazard_male_male <- exp(sum(mod2a$coef * inputs))
hazard_male_male
```

    [1] 0.008052391

Expected wait time

``` r
1 / (dyads_at_risk * hazard_male_male)
```

    [1] 4.139557

Expected wait of 4.14 minutes between events involving two boys. Compare
to girls:

``` r
inputs <- c(intercept = 1, Sender_male = 0, Receiver_male = 0)
dyads_at_risk <- 12 * 11
hazard_female_female <- exp(sum(mod2a$coef * inputs))
hazard_female_female
```

    [1] 0.02327429

``` r
1 / (dyads_at_risk * hazard_female_female)
```

    [1] 0.325499

Hazard is higher and wait time is much lower.

Add teacher to the model:

``` r
CovSnd2 <- cbind(attributes[, c("intercept", "male", "teacher")])
CovRec2 <- cbind(attributes[, c("male", "teacher")])
mod2b <- rem.dyad(edgelist_date1,
  n = class_size,
  effects = c("CovSnd", "CovRec"),
  covar = list(CovSnd = CovSnd2, CovRec = CovRec2),
  ordinal = F, hessian = T
)
```

    Prepping edgelist.
    Checking/prepping covariates.
    Computing preliminary statistics
    Fitting model
    Obtaining goodness-of-fit statistics

``` r
coef_names2b <- c(
  "Intercept", "Sender_male", "Sender_teacher",
  "Receiver_male", "Receiver_teacher"
)
names(mod2b$coef) <- coef_names2b
summary(mod2b)
```

    Relational Event Model (Temporal Likelihood)

                      Estimate   Std.Err  Z value  Pr(>|z|)    
    Intercept        -3.759707  0.084668 -44.4054 < 2.2e-16 ***
    Sender_male      -0.483081  0.164160  -2.9427  0.003253 ** 
    Sender_teacher   -1.132818  0.596658  -1.8986  0.057617 .  
    Receiver_male    -0.514723  0.169125  -3.0434  0.002339 ** 
    Receiver_teacher  0.280787  0.325987   0.8613  0.389048    
    ---
    Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
    Null deviance: 2306.34 on 228 degrees of freedom
    Residual deviance: 2276.504 on 224 degrees of freedom
        Chi-square: 29.83545 on 4 degrees of freedom, asymptotic p-value 5.286827e-06 
    AIC: 2286.504 AICC: 2286.775 BIC: 2303.651 

Adding teacher variables does not help. Compare the fit with BIC

``` r
mod2a$BIC - mod2b$BIC
```

    [1] -4.957228

Lower values are wanted, so the first model is better

## Adding Covariate Event Terms

Covariate events are predictors that are based on attributes of a dyad.
Here, we will add the seating structure of the class to the model. The
basic idea is that nodes who are close in the classroom are more likely
to talk to one another.

``` r
# url3 <- "https://github.com/JeffreyAlanSmith/Integrated_Network_Science/raw/master/data/class_seating_date1.txt"

seating_date1 <- read.table("../data/class_seating_date1.txt", header = T)
head(seating_date1)
```

      ego_id alter_id
    1      1        7
    2      1        9
    3      1       15
    4      2        3
    5      2        5
    6      2       11

As in the previous tutorial, the data is stored as an edgelist,
indicating if node i is sitting adjacent to node j. The rem.dyad()
function requires that this information be transformed into a matrix.
So, we will go ahead and create a matrix of seating, where there is a 1
if i and j are next to each other in the class and 0 otherwise. We will
accomplish this by taking the seating edgelist, turning it into a
directed network object, and then symmetrizing it to make it undirected
(this simply fixes any mistakes in the data where i may be recorded as
being next to j but j is not recorded as being next to i). We will use a
‘weak’ rule when symmetrizing the matrix, so if i is recorded as sitting
next to j or j is recorded as sitting next to i, the matrix will have a
1 for both ij and ji. Note that the symmetrize() function will output a
matrix by default.

``` r
library(magrittr)
seating_matrix_date1 <- network(
  x = seating_date1, directed = T,
  vertices = data.frame(ids = 1:class_size)
) %>%
  symmetrize(rule = "weak")
seating_matrix_date1
```

          [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] [,13]
     [1,]    0    0    0    0    0    0    1    0    1     0     0     0     0
     [2,]    0    0    1    0    1    0    0    0    0     0     1     0     0
     [3,]    0    1    0    0    1    0    0    0    0     0     1     1     0
     [4,]    0    0    0    0    0    1    0    1    0     0     0     0     0
     [5,]    0    1    1    0    0    0    0    0    0     0     1     1     0
     [6,]    0    0    0    1    0    0    0    1    0     0     0     1     0
     [7,]    1    0    0    0    0    0    0    0    1     0     0     0     0
     [8,]    0    0    0    1    0    1    0    0    0     0     0     0     0
     [9,]    1    0    0    0    0    0    1    0    0     0     0     0     0
    [10,]    0    0    0    0    0    0    0    0    0     0     0     0     0
    [11,]    0    1    1    0    1    0    0    0    0     0     0     0     0
    [12,]    0    0    1    0    1    1    0    0    0     0     0     0     0
    [13,]    0    0    0    0    0    0    0    0    0     0     0     0     0
    [14,]    0    0    0    1    0    1    0    1    0     0     0     0     0
    [15,]    1    0    0    0    0    0    1    0    1     0     0     0     0
    [16,]    0    0    0    0    0    0    0    0    0     0     0     1     0
    [17,]    0    1    1    0    1    0    0    0    0     0     1     0     0
    [18,]    0    0    0    1    0    1    0    1    0     0     0     0     0
          [,14] [,15] [,16] [,17] [,18]
     [1,]     0     1     0     0     0
     [2,]     0     0     0     1     0
     [3,]     0     0     0     1     0
     [4,]     1     0     0     0     1
     [5,]     0     0     0     1     0
     [6,]     1     0     0     0     1
     [7,]     0     1     0     0     0
     [8,]     1     0     0     0     1
     [9,]     0     1     0     0     0
    [10,]     0     0     0     0     0
    [11,]     0     0     0     1     0
    [12,]     0     0     1     0     0
    [13,]     0     0     0     0     0
    [14,]     0     0     0     0     1
    [15,]     0     0     0     0     0
    [16,]     0     0     0     0     0
    [17,]     0     0     0     0     0
    [18,]     1     0     0     0     0

``` r
mod3a <- rem.dyad(edgelist_date1,
  n = class_size,
  effects = c("CovSnd", "CovRec", "CovEvent"),
  covar = list(
    CovSnd = CovSnd1, CovRec = CovRec1,
    CovEvent = seating_matrix_date1
  ),
  ordinal = F, hessian = T
)
```

    Prepping edgelist.
    Checking/prepping covariates.
    Computing preliminary statistics
    Fitting model
    Obtaining goodness-of-fit statistics

``` r
mod2a$BIC - mod3a$BIC
```

    [1] 416.5262

The fit is dramatically improved, so seating arrangement strongly shape
what events occur.

Add friendship data.

``` r
# url4 <- "https://github.com/JeffreyAlanSmith/Integrated_Network_Science/raw/master/data/class_edgelist_sem2.txt"

friends_sem2 <- read.table("../data/class_edgelist_sem2.txt", header = T)
head(friends_sem2)
```

      sender receiver
    1      1        4
    2      1        5
    3      1        7
    4      1        9
    5      1       15
    6      2        3

``` r
friends_matrix_sem2 <-
  network(
    x = friends_sem2, directed = T,
    vertices = data.frame(ids = 1:class_size)
  ) %>%
  as.matrix()
friends_matrix_sem2
```

       1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18
    1  0 0 0 1 1 0 1 0 1  0  0  0  0  0  1  0  0  0
    2  0 0 1 0 1 0 0 0 0  0  1  0  0  0  0  0  1  0
    3  0 1 0 0 1 1 0 0 0  0  1  0  0  0  0  0  1  0
    4  0 1 0 0 0 1 0 0 0  0  0  0  0  1  0  0  0  1
    5  1 0 1 0 0 0 0 0 0  0  0  0  0  0  0  0  1  1
    6  0 0 0 0 0 0 0 0 0  0  0  0  0  0  0  0  0  0
    7  1 1 0 0 0 1 0 1 1  0  0  0  0  0  1  0  0  1
    8  0 0 0 1 0 1 0 0 0  0  0  0  0  1  0  0  0  1
    9  1 0 0 0 0 1 1 1 0  0  0  0  0  0  1  0  1  0
    10 0 0 0 0 0 0 0 0 0  0  0  0  0  0  0  0  0  0
    11 0 1 1 0 1 0 0 0 0  0  0  0  0  0  0  0  1  0
    12 0 0 0 0 0 0 0 0 0  0  0  0  0  0  0  0  0  0
    13 0 0 0 0 0 0 0 0 0  0  0  0  0  0  0  0  0  0
    14 1 0 0 1 0 1 0 1 0  0  0  0  0  0  0  0  0  1
    15 1 0 0 0 0 1 1 1 1  0  0  0  0  0  0  0  0  0
    16 0 0 0 0 0 0 0 0 0  0  0  0  0  0  0  0  0  0
    17 0 1 1 1 1 0 0 0 1  0  1  0  0  0  0  0  0  0
    18 0 0 0 1 0 1 0 0 0  0  0  0  0  1  0  0  0  0

The rem.dyad() function requires that multiple matrices first be put
together as an p X n X n array, where p is the number of matrices and n
is the size of the network.

``` r
CovEvent_date1 <- array(
  data = NA,
  dim = c(2, class_size, class_size)
)
CovEvent_date1[1, , ] <- seating_matrix_date1
CovEvent_date1[2, , ] <- friends_matrix_sem2
dim(CovEvent_date1)
```

    [1]  2 18 18

``` r
mod3b <- rem.dyad(edgelist_date1,
  n = class_size,
  effects = c("CovSnd", "CovRec", "CovEvent"),
  covar = list(
    CovSnd = CovSnd1,
    CovRec = CovRec1,
    CovEvent = CovEvent_date1
  ),
  ordinal = F, hessian = T
)
```

    Prepping edgelist.
    Checking/prepping covariates.
    Computing preliminary statistics
    Fitting model
    Obtaining goodness-of-fit statistics

``` r
names(mod3b$coef) <- c(
  "Intercept", "Sender_male", "Receiver_male",
  "Seating", "Friendship"
)
summary(mod3b)
```

    Relational Event Model (Temporal Likelihood)

                  Estimate  Std.Err  Z value  Pr(>|z|)    
    Intercept     -5.49675  0.17648 -31.1470 < 2.2e-16 ***
    Sender_male   -0.47785  0.16200  -2.9498  0.003180 ** 
    Receiver_male -0.43877  0.15428  -2.8440  0.004455 ** 
    Seating        1.82666  0.23713   7.7031 1.332e-14 ***
    Friendship     1.52491  0.23856   6.3921 1.636e-10 ***
    ---
    Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
    Null deviance: 2306.34 on 228 degrees of freedom
    Residual deviance: 1812.664 on 224 degrees of freedom
        Chi-square: 493.6753 on 4 degrees of freedom, asymptotic p-value 0 
    AIC: 1822.664 AICC: 1822.935 BIC: 1839.811 

Friendship and Seating are both predictive of interaction events. The
gender difference still exists and is significant.

# Micro Rules of Interaction

So far we have built up a simple but plausible model of interactions in
this classroom. Girls tend to talk more than boys, while friends and
those sitting close to each other also tend to interact during class.
What we have yet to capture is something about the ‘rules’ of
interaction. For example, we might expect turn taking (i talks to j and
then j talks to i) above what we can capture from friendship and seating
effects alone.

We will build up our model slowly, including more complicated rules as
we go along. As a start, let’s include terms that capture recency of
events. The two terms of interest are “RRecSnd” and “RSndSnd”. With
RRecSnd, we test if i is more likely to talk to j if j recently talked
to i. With RSndSnd, we test if i is more likely to talk to j if i
recently talked to j. The effects capture the idea that if j recently
talked to i (or i recently talked to j), then an i-\>j event is more
likely to be the next event. We will specify this model by including the
“RRecSnd” and “RSndSnd” in the vector of effects. Note that we do not
need to add anything to the covar list. For this first model we will not
control for friendship or seating.

``` r
mod4a <- rem.dyad(edgelist_date1, class_size,
  c("CovSnd", "CovRec", "RRecSnd", "RSndSnd"),
  covar = list(CovSnd = CovSnd1, CovRec = CovRec1),
  ordinal = F, hessian = T
)
```

    Prepping edgelist.
    Checking/prepping covariates.
    Computing preliminary statistics
    Fitting model
    Obtaining goodness-of-fit statistics

``` r
coef_names2a <- c("Intercept", "Sender_male", "Receiver_male")
names(mod4a$coef) <- c("Recency_ji", "Recency_ij", coef_names2a)
summary(mod4a)
```

    Relational Event Model (Temporal Likelihood)

                  Estimate  Std.Err  Z value  Pr(>|z|)    
    Recency_ji     6.31792  0.22376  28.2355 < 2.2e-16 ***
    Recency_ij    -2.44296  0.21764 -11.2250 < 2.2e-16 ***
    Intercept     -5.14311  0.14179 -36.2717 < 2.2e-16 ***
    Sender_male   -0.82672  0.17750  -4.6575   3.2e-06 ***
    Receiver_male -0.47810  0.16423  -2.9112  0.003601 ** 
    ---
    Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
    Null deviance: 2306.34 on 228 degrees of freedom
    Residual deviance: 1419.167 on 224 degrees of freedom
        Chi-square: 887.1722 on 4 degrees of freedom, asymptotic p-value 0 
    AIC: 1429.167 AICC: 1429.438 BIC: 1446.314 

If j recently talked to i, i is likely to respond. It is less likely
that the next event will be i to j if the recent event is also i to j.
Gender effects are still significant.

Full model, with seating and friendship:

``` r
mod4b <- rem.dyad(
  edgelist_date1, class_size,
  effects = c(
    "CovSnd", "CovRec",
    "CovEvent", "RRecSnd", "RSndSnd"
  ),
  covar = list(
    CovSnd = CovSnd1, CovRec = CovRec1,
    CovEvent = CovEvent_date1
  ),
  ordinal = F, hessian = T
)
```

    Prepping edgelist.
    Checking/prepping covariates.
    Computing preliminary statistics
    Fitting model
    Obtaining goodness-of-fit statistics

``` r
coef_names3b <- c(coef_names2a, "Seating", "Friendship")
coef_names4b <- c("Recency_ji", "Recency_ij", coef_names3b)
names(mod4b$coef) <- coef_names4b
```

``` r
summary(mod4b)
```

    Relational Event Model (Temporal Likelihood)

                   Estimate   Std.Err  Z value  Pr(>|z|)    
    Recency_ji     5.726043  0.223170  25.6577 < 2.2e-16 ***
    Recency_ij    -3.051556  0.224247 -13.6080 < 2.2e-16 ***
    Intercept     -6.070958  0.218092 -27.8367 < 2.2e-16 ***
    Sender_male   -0.201135  0.175123  -1.1485 0.2507489    
    Receiver_male -0.089231  0.164541  -0.5423 0.5876110    
    Seating        1.060937  0.278799   3.8054 0.0001416 ***
    Friendship     0.919032  0.272150   3.3769 0.0007330 ***
    ---
    Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
    Null deviance: 2306.34 on 228 degrees of freedom
    Residual deviance: 1348.516 on 222 degrees of freedom
        Chi-square: 957.8238 on 6 degrees of freedom, asymptotic p-value 0 
    AIC: 1362.516 AICC: 1363.025 BIC: 1386.521 

``` r
mod3b$BIC - mod4b$BIC
```

    [1] 453.2898

The model is greatly improved, but the gender coefficients are no longer
significant.

We will now consider terms that capture p-shifts, or participation
shifts. p-shifts are based strictly on the most recent event that
occurred, rather than recency effects which can go back further in time.
The idea is to capture micro rules in how interactions play out, based
on the last interaction that took place. For our first example, we will
add a turn taking rule, where A talks to B and the very next event is B
talking to A. This is specified as “PSAB-BA” (as part of the effects
vector). The rest of the model is the same as the previous model.

``` r
mod4c <- rem.dyad(
  edgelist_date1, class_size,
  effects = c(
    "CovSnd", "CovRec", "CovEvent",
    "RRecSnd", "RSndSnd", "PSAB-BA"
  ),
  covar = list(
    CovSnd = CovSnd1, CovRec = CovRec1,
    CovEvent = CovEvent_date1
  ),
  ordinal = F, hessian = T
)
```

    Prepping edgelist.
    Checking/prepping covariates.
    Computing preliminary statistics
    Fitting model
    Obtaining goodness-of-fit statistics

``` r
coef_names4c <- c(coef_names4b, "PSAB_BA")
names(mod4c$coef) <- coef_names4c
summary(mod4c)
```

    Relational Event Model (Temporal Likelihood)

                   Estimate   Std.Err  Z value  Pr(>|z|)    
    Recency_ji     3.140606  0.300287  10.4587 < 2.2e-16 ***
    Recency_ij    -1.447230  0.209216  -6.9174   4.6e-12 ***
    Intercept     -6.023163  0.207242 -29.0635 < 2.2e-16 ***
    Sender_male    0.003476  0.168344   0.0206  0.983526    
    Receiver_male  0.135468  0.162346   0.8344  0.404031    
    Seating        0.960246  0.252733   3.7995  0.000145 ***
    Friendship     0.892416  0.249509   3.5767  0.000348 ***
    PSAB_BA        3.334932  0.187187  17.8161 < 2.2e-16 ***
    ---
    Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
    Null deviance: 2306.34 on 228 degrees of freedom
    Residual deviance: 1006.862 on 221 degrees of freedom
        Chi-square: 1299.478 on 7 degrees of freedom, asymptotic p-value 0 
    AIC: 1022.862 AICC: 1023.519 BIC: 1050.296 

We can see that the fit is improved greatly, as there is a large effect
of turn taking in social interactions. We can also see that the effects
for recency are much reduced from the previous model. Now, let’s add a
somewhat more complicated interactional rule. Here we will add a term
for ‘turn continuing’, “PSAB-AY”. This means that A talks with B and the
very next event is A talking to someone else (besides B). We will also
add a term for ‘turn receiving’, “PSAB-BY”. Here, A talks to B and the
very next event is B talking to someone else (besides A).

``` r
mod4d <- rem.dyad(
  edgelist_date1, class_size,
  effects = c(
    "CovSnd", "CovRec", "CovEvent",
    "RRecSnd", "RSndSnd", "PSAB-BA",
    "PSAB-BY", "PSAB-AY"
  ),
  covar = list(
    CovSnd = CovSnd1, CovRec = CovRec1,
    CovEvent = CovEvent_date1
  ),
  ordinal = F, hessian = T
)
```

    Prepping edgelist.
    Checking/prepping covariates.
    Computing preliminary statistics
    Fitting model
    Obtaining goodness-of-fit statistics

``` r
coef_names4d <- c(coef_names4b, "PSAB_BA", "PSAB_BY", "PSAB_AY")
names(mod4d$coef) <- coef_names4d
summary(mod4d)
```

    Relational Event Model (Temporal Likelihood)

                   Estimate   Std.Err  Z value  Pr(>|z|)    
    Recency_ji     3.277777  0.306179  10.7054 < 2.2e-16 ***
    Recency_ij    -1.445961  0.209454  -6.9035 5.075e-12 ***
    Intercept     -6.166485  0.218192 -28.2618 < 2.2e-16 ***
    Sender_male    0.026808  0.168883   0.1587 0.8738780    
    Receiver_male  0.148636  0.162911   0.9124 0.3615686    
    Seating        0.960883  0.253534   3.7900 0.0001507 ***
    Friendship     0.858668  0.249638   3.4396 0.0005825 ***
    PSAB_BA        3.364802  0.190062  17.7037 < 2.2e-16 ***
    PSAB_BY        1.180495  0.305239   3.8675 0.0001100 ***
    PSAB_AY        0.098791  0.423885   0.2331 0.8157150    
    ---
    Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
    Null deviance: 2306.34 on 228 degrees of freedom
    Residual deviance: 995.3731 on 219 degrees of freedom
        Chi-square: 1310.967 on 9 degrees of freedom, asymptotic p-value 0 
    AIC: 1015.373 AICC: 1016.387 BIC: 1049.667 

It is likely that once A talks, B will either respond directly or send a
message to someone else. It is not likely A will send another message.

``` r
mod4c$BIC - mod4d$BIC
```

    [1] 0.6297514

The fit is improved.

Let’s look at one more set of terms, here focusing on interactional
tendencies related to usurping the conversation. We include p-shift
terms for “PSAB-XA” and “PSAB-XB”. With PSAB-XA, A talks to B and then
another node (X) usurps the conversation and answers A. With PSAB-XB, A
talks to B and then another node (X) usurps the conversation and talks
to B. In both cases, a node talks ‘out of turn’ relative to the previous
event. Let’s go ahead and add these terms to the model.

``` r
mod4e <- rem.dyad(edgelist_date1,
  n = class_size,
  effects = c(
    "CovSnd", "CovRec", "CovEvent", "RRecSnd",
    "RSndSnd", "PSAB-BA", "PSAB-BY",
    "PSAB-AY", "PSAB-XA", "PSAB-XB"
  ),
  covar = list(
    CovSnd = CovSnd1, CovRec = CovRec1,
    CovEvent = CovEvent_date1
  ),
  ordinal = FALSE, hessian = TRUE
)
```

    Prepping edgelist.
    Checking/prepping covariates.
    Computing preliminary statistics
    Fitting model
    Obtaining goodness-of-fit statistics

``` r
coef_names4e <- c(
  coef_names4b, "PSAB_BA", "PSAB_BY", "PSAB_XA",
  "PSAB_XB", "PSAB_AY"
)
names(mod4e$coef) <- coef_names4e
summary(mod4e)
```

    Relational Event Model (Temporal Likelihood)

                   Estimate   Std.Err  Z value  Pr(>|z|)    
    Recency_ji     3.255338  0.305936  10.6406 < 2.2e-16 ***
    Recency_ij    -1.435095  0.208876  -6.8706 6.394e-12 ***
    Intercept     -6.345151  0.229722 -27.6210 < 2.2e-16 ***
    Sender_male    0.052905  0.169351   0.3124 0.7547376    
    Receiver_male  0.189967  0.163464   1.1621 0.2451803    
    Seating        0.965638  0.252719   3.8210 0.0001329 ***
    Friendship     0.869857  0.248674   3.4980 0.0004688 ***
    PSAB_BA        3.532669  0.200569  17.6133 < 2.2e-16 ***
    PSAB_BY        1.332495  0.311164   4.2823 1.850e-05 ***
    PSAB_XA        0.389228  0.397964   0.9780 0.3280506    
    PSAB_XB        1.179550  0.286743   4.1136 3.895e-05 ***
    PSAB_AY        0.256821  0.428279   0.5997 0.5487333    
    ---
    Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
    Null deviance: 2306.34 on 228 degrees of freedom
    Residual deviance: 981.8918 on 217 degrees of freedom
        Chi-square: 1324.448 on 11 degrees of freedom, asymptotic p-value 0 
    AIC: 1005.892 AICC: 1007.343 BIC: 1047.044 

``` r
mod4d$BIC - mod4e$BIC
```

    [1] 2.622676

The fit is improved. If one usurps the conversation, it will be directed
at B.

The basic rules could be summarized as: if A talks to B then the next
event should be B to A; B to someone else; or someone else to B. Thus,
there are clear norms about turn taking. If A talks to B, B is very
likely to be part of the next event (one way or another). Of course, we
could imagine looking at other kinds of terms, but this is pretty good
start to the model.

# Assessing Model Fit

We can look at the residuals and the predicted classification to see how
well the model is actually predicting the data. Here we will work with
mod4e, our preferred model from above.

``` r
head(mod4e$predicted.match)
```

      send_col receive_col
    1    FALSE       FALSE
    2     TRUE        TRUE
    3    FALSE       FALSE
    4     TRUE        TRUE
    5    FALSE       FALSE
    6     TRUE        TRUE

``` r
send_col <- mod4e$predicted.match[, "send_col"]
receive_col <- mod4e$predicted.match[, "receive_col"]

table(send_col, receive_col)
```

            receive_col
    send_col FALSE TRUE
       FALSE    89    6
       TRUE     14  119

``` r
prop.table(table(send_col, receive_col))
```

            receive_col
    send_col      FALSE       TRUE
       FALSE 0.39035088 0.02631579
       TRUE  0.06140351 0.52192982

52% Exactly correct, 39% complete miss. Let’s see where the model is not
performing well.

``` r
summary(mod4e$residuals)
```

       Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
    -2.2790 -0.8395  1.2354  4.3030  8.7932 25.5613 

Consider cases with high residuals.

``` r
high_residuals <- which(mod4e$residuals > 10)
edgelist_date1[high_residuals, ]
```

        time_estimate_col send_col receive_col
    5               0.714        9           8
    9               1.429        3          11
    21              3.286        8           7
    25              4.286        5           2
    37              6.321        3           2
    45              7.393       18           4
    55              8.893       11           3
    57             10.041       14          18
    59             10.419        5           2
    71             12.595        5          17
    79             13.446        9           8
    101            16.391        3          12
    104            16.913       11          12
    106            17.826        3          12
    107            18.609        2          17
    111            19.789       15           8
    113            21.105       11          12
    119            22.289       11           2
    121            22.947        4          14
    127            24.500        8          12
    130            25.125        8          12
    154            26.970       11          12
    155            27.091        2          12
    156            27.333       11          12
    157            27.455        2          12
    160            28.909       11          12
    165            29.758        8          12
    184            33.152       11          17
    188            34.640        7           1
    200            37.520       11          17
    204            38.566        5           2
    210            39.132        8          15
    212            39.321        1           8
    216            39.698        8          15
    235            40.264        7           8
    260            41.208        8          15
    278            42.906        7           8

``` r
attributes[12, ]
```

       id gnd grd rce intercept male teacher
    12 12   1  16   3         1    1       1

12 is a teacher. We can try adding it back in.

``` r
mod4f <- rem.dyad(
  edgelist_date1, class_size,
  effects = c(
    "CovSnd", "CovRec", "CovEvent", "RRecSnd",
    "RSndSnd", "PSAB-BA", "PSAB-BY",
    "PSAB-AY", "PSAB-XA", "PSAB-XB"
  ),
  covar = list(
    CovSnd = CovSnd2, CovRec = CovRec2,
    CovEvent = CovEvent_date1
  ),
  ordinal = FALSE, hessian = TRUE
)
```

    Prepping edgelist.
    Checking/prepping covariates.
    Computing preliminary statistics
    Fitting model
    Obtaining goodness-of-fit statistics

``` r
coef_names4f <- c(
  "Recency_ji", "Recency_ij", "Intercept",
  "Sender_male", "Sender_teacher",
  "Receiver_male", "Receiver_teacher",
  "Seating", "Friendship",
  "PSAB_BA", "PSAB_BY",
  "PSAB_XA", "PSAB_XB", "PSAB_AY"
)

names(mod4f$coef) <- coef_names4f
mod4e$BIC - mod4f$BIC
```

    [1] 8.172223

``` r
summary(mod4f)
```

    Relational Event Model (Temporal Likelihood)

                      Estimate   Std.Err  Z value  Pr(>|z|)    
    Recency_ji        3.505506  0.324673  10.7970 < 2.2e-16 ***
    Recency_ij       -1.576365  0.210816  -7.4774 7.572e-14 ***
    Intercept        -6.447588  0.242987 -26.5348 < 2.2e-16 ***
    Sender_male       0.214756  0.171487   1.2523 0.2104552    
    Sender_teacher   -1.149421  0.635660  -1.8082 0.0705705 .  
    Receiver_male     0.015541  0.179620   0.0865 0.9310506    
    Receiver_teacher  1.430996  0.381854   3.7475 0.0001786 ***
    Seating           0.858010  0.256410   3.3462 0.0008192 ***
    Friendship        0.992710  0.292980   3.3883 0.0007032 ***
    PSAB_BA           3.478438  0.202099  17.2116 < 2.2e-16 ***
    PSAB_BY           1.361892  0.311835   4.3674 1.258e-05 ***
    PSAB_XA           0.400084  0.398098   1.0050 0.3149026    
    PSAB_XB           1.151173  0.286732   4.0148 5.949e-05 ***
    PSAB_AY           0.231012  0.428205   0.5395 0.5895498    
    ---
    Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
    Null deviance: 2306.34 on 228 degrees of freedom
    Residual deviance: 962.8608 on 215 degrees of freedom
        Chi-square: 1343.479 on 13 degrees of freedom, asymptotic p-value 0 
    AIC: 990.8608 AICC: 992.8327 BIC: 1038.872 

We can see that the teacher is part of more interactions as the receiver
(being talked to) than we would expect based on other terms in the
model. This is likely the case because the teacher can easily talk to
anyone in the class (i.e., the teacher is not subject to only talking to
those adjacent to them in the classroom), and so the term on the seating
arrangement pushes the previous model to under predict interactions with
the teacher. This is now rectified in the current model.

``` r
send_col <- mod4f$predicted.match[, "send_col"]
receive_col <- mod4f$predicted.match[, "receive_col"]

prop.table(table(send_col, receive_col))
```

            receive_col
    send_col      FALSE       TRUE
       FALSE 0.39035088 0.03508772
       TRUE  0.05701754 0.51754386

Performance is still worse.

# Comparison to a second date

We have so far run a number of models, interpreted the results and
learned a bit about the interactional dynamics in this classroom. Here,
we run through the same exercise (an abbreviated version) using
interactional data from a different date. The classroom is the same, so
the actors are the same, but this class takes place later in the second
semester. More importantly, this was a date where there was a great deal
more misbehaving in the class and the teacher had to sanction students
to a much larger extent. Our question is how (or if) the interactional
tendencies are different in a day where the class is less orderly and
controlled.

``` r
library(tidyverse)
```

    ── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──
    ✔ dplyr     1.1.4     ✔ readr     2.1.5
    ✔ forcats   1.0.0     ✔ stringr   1.5.1
    ✔ ggplot2   3.5.1     ✔ tibble    3.2.1
    ✔ lubridate 1.9.4     ✔ tidyr     1.3.1
    ✔ purrr     1.0.4     
    ── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──
    ✖ tidyr::extract()   masks magrittr::extract()
    ✖ dplyr::filter()    masks stats::filter()
    ✖ dplyr::lag()       masks stats::lag()
    ✖ dplyr::recode()    masks car::recode()
    ✖ purrr::set_names() masks magrittr::set_names()
    ✖ purrr::some()      masks car::some()
    ℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors

``` r
# url5 <- "https://github.com/JeffreyAlanSmith/Integrated_Network_Science/raw/master/data/class_interactions_date2.txt"

interactions_date2 <-
  read.table("../data/class_interactions_date2.txt",
    header = T
  ) %>%
  filter(to_all_col == 0 & from_all_col == 0)
```

``` r
var_names <- c("time_estimate_col", "send_col", "receive_col")
edgelist_date2 <- as.matrix(interactions_date2[, var_names]) %>%
  rbind(c(33.10, NA, NA))
tail(edgelist_date2)
```

           time_estimate_col send_col receive_col
    [280,]            32.394       11          17
    [281,]            32.545       17           5
    [282,]            32.697        5          17
    [283,]            32.848        8           6
    [284,]            33.000        6           8
    [285,]            33.100       NA          NA

``` r
# url6 <- "https://github.com/JeffreyAlanSmith/Integrated_Network_Science/raw/master/data/class_seating_date2.txt"

seating_date2 <- read.table("../data/class_seating_date2.txt",
  header = T
)
head(seating_date2)
```

      ego_id alter_id
    1      1        7
    2      3        5
    3      3       11
    4      3       17
    5      4       14
    6      4       18

``` r
seating_matrix_date2 <-
  network(seating_date2,
    directed = T,
    vertices = data.frame(ids = 1:class_size)
  ) %>%
  symmetrize(rule = "weak")

CovEvent_date2 <- array(data = NA, dim = c(2, class_size, class_size))
CovEvent_date2[1, , ] <- seating_matrix_date2
CovEvent_date2[2, , ] <- friends_matrix_sem2
```

``` r
mod4f_date2 <- rem.dyad(edgelist_date2,
  n = class_size,
  effects = c(
    "CovSnd", "CovRec",
    "CovEvent", "RRecSnd", "RSndSnd",
    "PSAB-BA", "PSAB-BY", "PSAB-AY",
    "PSAB-XA", "PSAB-XB"
  ),
  covar = list(
    CovSnd = CovSnd2,
    CovRec = CovRec2,
    CovEvent = CovEvent_date2
  ),
  ordinal = FALSE, hessian = TRUE
)
```

    Prepping edgelist.
    Checking/prepping covariates.
    Computing preliminary statistics
    Fitting model
    Obtaining goodness-of-fit statistics

``` r
names(mod4f_date2$coef) <- coef_names4f
summary(mod4f_date2)
```

    Relational Event Model (Temporal Likelihood)

                      Estimate   Std.Err  Z value  Pr(>|z|)    
    Recency_ji        2.750092  0.308911   8.9025 < 2.2e-16 ***
    Recency_ij       -0.669370  0.211804  -3.1603  0.001576 ** 
    Intercept        -7.099886  0.302568 -23.4654 < 2.2e-16 ***
    Sender_male       0.151139  0.139798   1.0811  0.279642    
    Sender_teacher    0.634205  0.445497   1.4236  0.154565    
    Receiver_male     0.028306  0.143930   0.1967  0.844092    
    Receiver_teacher  2.368032  0.337426   7.0179 2.252e-12 ***
    Seating           1.569588  0.254592   6.1651 7.044e-10 ***
    Friendship        1.442184  0.294274   4.9008 9.544e-07 ***
    PSAB_BA           3.613255  0.160671  22.4885 < 2.2e-16 ***
    PSAB_BY           1.980620  0.270850   7.3126 2.620e-13 ***
    PSAB_XA           0.722112  0.371721   1.9426  0.052063 .  
    PSAB_XB           0.968850  0.313228   3.0931  0.001981 ** 
    PSAB_AY           0.538711  0.398295   1.3525  0.176202    
    ---
    Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
    Null deviance: 2598.114 on 284 degrees of freedom
    Residual deviance: 704.5596 on 271 degrees of freedom
        Chi-square: 1893.554 on 13 degrees of freedom, asymptotic p-value 0 
    AIC: 732.5596 AICC: 734.1209 BIC: 783.6452 

``` r
compare_coefs <- data.frame(date1 = mod4f$coef, date2 = mod4f_date2$coef)
compare_coefs
```

                           date1       date2
    Recency_ji        3.50550601  2.75009196
    Recency_ij       -1.57636457 -0.66937029
    Intercept        -6.44758831 -7.09988561
    Sender_male       0.21475577  0.15113896
    Sender_teacher   -1.14942066  0.63420517
    Receiver_male     0.01554129  0.02830567
    Receiver_teacher  1.43099565  2.36803171
    Seating           0.85801050  1.56958781
    Friendship        0.99271044  1.44218436
    PSAB_BA           3.47843790  3.61325458
    PSAB_BY           1.36189185  1.98061985
    PSAB_XA           0.40008419  0.72211177
    PSAB_XB           1.15117313  0.96885043
    PSAB_AY           0.23101154  0.53871089

The effects for friendship and seating are particularly important for
the second day. Similarly, there is some evidence that the tendency for
PSAB-BY p-shifts are relatively high here. A class that is more unruly
tends to have interactions that are based more on friendship and
adjacent seating (i.e. talking to neighbors rather than doing
discussion). Additionally, there may be a higher (relative) tendency for
nodes to form a kind of two-step interaction (A-B-Y) rather than just a
simple return to the person addressing them (A-B-A). This would
potentially create more disruption in the classroom, as a larger number
of students are brought into the initial interaction event.
